color = "black",
position = position_dodge(width = dw),
size = 1,
linewidth = .75,
show.legend = FALSE
) +
# intercept
geom_hline(yintercept = rt_mean_explicit, linetype = 2) +
labs(
x = NULL,
y = "Response time (ms)"
) +
scale_x_discrete(labels = c("Congruent", "Incongruent")) +
scale_fill_okabeito(name = "Aphantasia: ", labels = c("Yes", "No")) +
scale_color_okabeito(guide = NULL)
#| label: fig-model_plots_im
#| fig-cap: "Plots for the effects of interest in the implicit task."
#| fig-subcap:
#|   - "Group x Congruence interaction in the GLMM for the implicit task."
#|   - "Group x Congruence interaction in the LMM for the implicit task."
# ─── Model effects plot ───────────────────────────
df_implicit_rt |>
ggplot(aes(
x = congruence,
y = rt,
fill = aphantasia,
color = aphantasia
)) +
# linear modelling of the differences
geom_line(
data = best_glmm_implcit_preds,
aes(
y = Mean,
group = aphantasia
),
position = position_dodge(width = dw),
linewidth = 1.5,
linetype = 1,
show.legend = FALSE
) +
# predicted means of the model
geom_pointrange2(
data = best_glmm_implcit_preds,
aes(
x = congruence,
y = Mean,
ymin = CI_low,
ymax = CI_high,
group = aphantasia
),
color = "black",
position = position_dodge(width = dw),
size = 1,
linewidth = .75,
show.legend = FALSE
) +
# intercept
geom_hline(yintercept = rt_mean_implicit, linetype = 2) +
labs(
x = NULL,
y = "Response time (ms)"
) +
scale_x_discrete(labels = c("Congruent", "Incongruent")) +
scale_fill_okabeito(name = "Aphantasia: ", labels = c("Yes", "No")) +
scale_color_okabeito(guide = NULL)
#| output: false
# ═══ Fitting Generalized Linear Mixed Models in parallel ══════════════════════
# ─── Preparing variable roles ─────────────────────────────────────────────────
model_recipe_glmm_ex_continuous <-
df_explicit_rt |>
recipe() |>
update_role(rt, new_role = "outcome") %>%
update_role(
subjectid, age, visual_imagery, spatial_imagery, color, congruence,
new_role = "predictor"
) |>
add_role(subjectid, new_role = "group")
#| code-summary: "Computing the PCA"
#| echo: true
# ─── Principal Component Analysis ───
pca <-
principal_components(
df_questionnaires[,4:7],
n = "max",
sort = TRUE,
standardize = TRUE
)
#| label: tbl-pca_tables
#| tbl-cap: "Results of the Principal Components Analysis."
#| tbl-subcap:
#|   - "Loadings of each variable on the three components extracted by the PCA."
#|   - "Eigenvalues and variance explained by the three components extracted by the PCA."
#| layout-ncol: 2
# ─── Loadings ───
pca |>
as.data.frame() |>
mutate(Variable = case_when(
Variable == "suis60" ~ "SUIS",
Variable == "vviq80" ~ "VVIQ",
Variable == "osiq_o75" ~ "OSIQ-O",
Variable == "osiq_s75" ~ "OSIQ-S",
TRUE ~ Variable
)) |>
display()
# ─── Eigenvalues and variance ───
pca |>
summary() |>
as.data.frame() |>
display()
#| code-summary: "Adding the predicted PCA components to the data"
#| echo: true
# ─── Adding components to the data ───
pca_components <- pca |> predict()
df_questionnaires <-
bind_cols(df_questionnaires[,1:8], pca_components[,1:2]) %>%
mutate(PC2 = -PC2) %>%
rename(
"visual_imagery" = PC1,
"spatial_imagery" = PC2
)
# updating all the dataframes with the imagery variables
dfs <-
list(
implicit_task = df_implicit_rt,
explicit_task = df_explicit_rt
) %>%
# adding the new variables to each dataframe
imap(~left_join(
.x |> select(-c(rt_mean, rt_mad)),
df_questionnaires %>%
select(
# column to match with the correct participants
subjectid,
# new variables to add
visual_imagery,
spatial_imagery),
by = "subjectid") %>%
# reordering the final dfs
select(
subjectid,
age, aphantasia,
visual_imagery, spatial_imagery,
everything())
)
View(df_explicit_rt)
#| code-summary: "Adding the predicted PCA components to the data"
#| echo: true
# ─── Adding components to the data ───
pca_components <- pca |> predict()
df_questionnaires <-
bind_cols(df_questionnaires[,1:8], pca_components[,1:2]) %>%
mutate(PC2 = -PC2) %>%
rename(
"visual_imagery" = PC1,
"spatial_imagery" = PC2
)
# updating all the dataframes with the imagery variables
dfs <-
list(
implicit_task = df_implicit_rt,
explicit_task = df_explicit_rt
) %>%
# adding the new variables to each dataframe
imap(~left_join(
.x |> select(-c(rt_median, rt_mad)),
df_questionnaires %>%
select(
# column to match with the correct participants
subjectid,
# new variables to add
visual_imagery,
spatial_imagery),
by = "subjectid") %>%
# reordering the final dfs
select(
subjectid,
age, aphantasia,
visual_imagery, spatial_imagery,
everything())
)
df_implicit_rt <- dfs$implicit_task
df_explicit_rt <- dfs$explicit_task
rm(dfs)
#| output: false
# ═══ Fitting Generalized Linear Mixed Models in parallel ══════════════════════
# ─── Preparing variable roles ─────────────────────────────────────────────────
model_recipe_glmm_ex_continuous <-
df_explicit_rt |>
recipe() |>
update_role(rt, new_role = "outcome") %>%
update_role(
subjectid, age, visual_imagery, spatial_imagery, color, congruence,
new_role = "predictor"
) |>
add_role(subjectid, new_role = "group")
model_recipe_glmm_im_continuous <-
df_implicit_rt |>
recipe() |>
update_role(rt, new_role = "outcome") %>%
update_role(
subjectid, age, visual_imagery, spatial_imagery, color, congruence,
new_role = "predictor"
) |>
add_role(subjectid, new_role = "group")
# ─── Writing down the formulas of our models ──────────────────────────────────
# null model
formula_0_continuous <- rt ~ (1|subjectid)
# intercept by-participant only
formula_1_continuous <- rt ~ (visual_imagery + spatial_imagery + congruence + color)^2 + (1|subjectid)
# intercept and slope on congruence by-participant
formula_2_continuous <- rt ~ (visual_imagery + spatial_imagery + congruence + color)^2 + (congruence|subjectid)
# intercept and slope on color by-participant
formula_3_continuous <- rt ~ (visual_imagery + spatial_imagery + congruence + color)^2 + (color|subjectid)
# intercept and slope on congruence and color by-participant
# formula_4_continuous <- rt ~ (visual_imagery + spatial_imagery + congruence + color)^2 + (congruence|subjectid) + (color|subjectid)
# Listing these formulas
model_formulas_continuous <- list(
formula_0 = formula_0_continuous,
formula_1 = formula_1_continuous,
formula_2 = formula_2_continuous,
formula_3 = formula_3_continuous
# formula_4 = formula_4_continuous
)
# ─── Table to combine everything in workflows and fit the models ──────────────
# (
model_all_fitted_continuous <-
tribble(       ~recipe,     ~ task,           ~model,       ~formula,
model_recipe_glmm_ex_continuous, "explicit", model_specs_glmm, model_formulas_continuous,
model_recipe_glmm_im_continuous, "implicit", model_specs_glmm, model_formulas_continuous
) |>
# combining recipes with models
unnest_longer(model) |>
# combining them with formulas
unnest_longer(formula) |>
rowwise() |>
mutate(
# creating workflows
workflow = list(
workflow() |>
add_recipe(recipe) |>
add_model(model, formula = formula)
)
)
# ─── Fitting the models with parallel processing ──────────────────────────────
# finding the available cores for parallel processing
n_cores <- parallel::detectCores() - 1
# creating the cluster of cores
parallel_cluster <-
parallel::makeCluster(
n_cores,
type = "PSOCK"
)
# registering the cluster for `foreach`
doParallel::registerDoParallel(cl = parallel_cluster)
# checking
# foreach::getDoParRegistered()
# foreach::getDoParWorkers()
# creating a new list-column with all the models fitted in parallel
(model_all_fitted_continuous$fitted_model <-
foreach(
workflow = model_all_fitted_continuous$workflow,
task     = model_all_fitted_continuous$task,
.combine  = "c",
.packages = c("tidymodels", "multilevelmod")
) %dopar% {
if(task == "explicit"){
model_fit <-
list(
workflow |>
fit(data = df_explicit_rt) |>
extract_fit_engine()
)
}
else{
model_fit <-
list(
workflow |>
fit(data = df_implicit_rt) |>
extract_fit_engine()
)
}
return(model_fit)
# measuring runtime for benchmarking
}) |> system.time() -> time_parallel
model_all_fitted_continuous <-
model_all_fitted_continuous |>
select(-c(recipe, model, formula, workflow))
# ─── Examining the quality of the models, estimating the parameters ───────────
model_all_fitted_continuous$parameters <-
foreach(
fitted_model = model_all_fitted_continuous$fitted_model,
.combine  = "c",
.packages = c("parameters")
) %dopar% {
parameters <- list(model_parameters(fitted_model))
return(parameters)
}
model_all_fitted_continuous$convergence <-
foreach(
fitted_model = model_all_fitted_continuous$fitted_model,
.combine  = "c",
.packages = c("performance")
) %dopar% {
convergence <- check_convergence(fitted_model)
return(convergence)
}
model_all_fitted_continuous$model_perf <-
foreach(
fitted_model = model_all_fitted_continuous$fitted_model,
.combine  = "c",
.packages = c("performance")
) %dopar% {
model_perf <- list(model_performance(fitted_model))
return(model_perf)
}
model_all_fitted_continuous <-
model_all_fitted_continuous |>
mutate(
# extracting model quality indices
AIC  = model_perf[[1]],
AICc = model_perf[[2]],
BIC  = model_perf[[3]]
) |>
ungroup() |>
select(-model_perf)
# stopping the cluster when we're done
parallel::stopCluster(cl = parallel_cluster)
# 214 seconds (3min30s)
# ─── Comparing the models' quality among those that converged ─────────────────
model_selection_continuous <-
model_all_fitted_continuous |>
filter(
formula_id != "formula_0" &
convergence == TRUE
) |>
group_by(task, model_id) |>
mutate(best_model = ifelse(AICc == min(AICc), TRUE, FALSE)) |>
filter(best_model == TRUE)
View(model_selection_continuous)
View(model_selection_continuous[[5]][[1]])
model_selection_continuous[[5]][[1]]
model_selection_continuous[[5]][[2]]
best_glmm_explicit_continuous <- model_selection_continuous[[4]][[1]]
best_glmm_implicit_continuous <- model_selection_continuous[[4]][[2]]
vizdata_glmm_explicit <-
df_explicit_rt |>
visualisation_matrix(
at = c("visual_imagery", "congruence"),
length = 100,
preserve_range = TRUE
)
vizdata_glmm_explicit <-
vizdata_glmm_explicit |>
mutate(predicted = insight::get_predicted(
best_glmm_explicit_continuous,
vizdata_glmm_explicit
)) |>
mutate(congruence = ifelse(congruence == "congruent", "Congruent", "Incongruent"))
df_explicit_rt |>
mutate(congruence = ifelse(congruence == "congruent", "Congruent", "Incongruent")) |>
ggplot(aes(
x = visual_imagery,
y = rt,
color = congruence
)) +
geom_line(
data = vizdata_glmm_explicit,
aes(
y = predicted,
group = congruence
),
size = 1.5
) +
geom_vline(xintercept = 0, linetype = 2) +
coord_cartesian(
ylim = c(400,600)
) +
labs(
title = "Explicit task",
x = "",
y = ""
) +
scale_color_lancet(name = "Congruence") +
theme(
title = element_text(size = txt),
axis.text = element_text(size = txt/2),
legend.text = element_text(size = txt),
legend.title = element_text(size = txt)
)
vizdata_glmm_implicit <-
df_implicit_rt |>
visualisation_matrix(
at = c("visual_imagery", "congruence"),
length = 100,
preserve_range = TRUE
)
vizdata_glmm_implicit <-
vizdata_glmm_implicit |>
mutate(predicted = insight::get_predicted(
best_glmm_implicit_continuous,
vizdata_glmm_implicit
)) |>
mutate(congruence = ifelse(congruence == "congruent", "Congruent", "Incongruent"))
df_implicit_rt |>
mutate(congruence = ifelse(congruence == "congruent", "Congruent", "Incongruent")) |>
ggplot(aes(
x = visual_imagery,
y = rt,
color = congruence
)) +
geom_line(
data = vizdata_glmm_implicit,
aes(
y = predicted,
group = congruence
),
size = 1.5
) +
geom_vline(xintercept = 0, linetype = 2) +
coord_cartesian(
ylim = c(400,600)
) +
labs(
title = "Explicit task",
x = "",
y = ""
) +
scale_color_lancet(name = "Congruence") +
theme(
title = element_text(size = txt),
axis.text = element_text(size = txt/2),
legend.text = element_text(size = txt),
legend.title = element_text(size = txt)
)
vizdata_glmm_visi_explicit <-
df_explicit_rt |>
visualisation_matrix(c("visual_imagery", "spatial_imagery"), length = 100) |>
visualisation_matrix("visual_imagery", length = 15, numerics = "all")
vizdata_glmm_visi_explicit$predicted <-
insight::get_predicted(
best_glmm_explicit_continuous,
vizdata_glmm_visi_explicit
)
df_explicit_rt |>
ggplot(aes(
x = visual_imagery,
y = rt,
color = spatial_imagery
)) +
geom_line(
data = vizdata_glmm_visi_explicit,
aes(
y = predicted,
group = spatial_imagery
),
size = 1
) +
geom_vline(xintercept = 0, linetype = 2) +
coord_cartesian(
ylim = c(150, 950)
) +
labs(
title = "Explicit task",
x = "",
y = ""
) +
scale_color_viridis(name = "Spatial imagery") +
theme(
title = element_text(size = txt),
axis.text = element_text(size = txt/2),
legend.text = element_text(size = txt/2),
legend.title = element_text(size = txt)
)
vizdata_glmm_visi_implicit <-
df_implicit_rt |>
visualisation_matrix(c("visual_imagery", "spatial_imagery"), length = 100) |>
visualisation_matrix("visual_imagery", length = 15, numerics = "all")
vizdata_glmm_visi_implicit$predicted <-
insight::get_predicted(
best_glmm_implicit_continuous,
vizdata_glmm_visi_implicit
)
df_implicit_rt |>
ggplot(aes(
x = visual_imagery,
y = rt,
color = spatial_imagery
)) +
geom_line(
data = vizdata_glmm_visi_implicit,
aes(
y = predicted,
group = spatial_imagery
),
size = 1
) +
geom_vline(xintercept = 0, linetype = 2) +
coord_cartesian(
ylim = c(350, 750)
) +
labs(
title = "Implicit task",
x = "",
y = ""
) +
scale_color_viridis(name = "Spatial imagery") +
theme(
title = element_text(size = txt),
axis.text = element_text(size = txt/2),
legend.text = element_text(size = txt/2),
legend.title = element_text(size = txt)
)
